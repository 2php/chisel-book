\input{slides_common}

\newif\ifbook
\input{../shared/chisel}

\title{Refactor of State Machines}
\author{Martin Schoeberl}
\date{\today}
\institute{Technical University of Denmark\\
Embedded Systems Engineering}

\begin{document}

\begin{frame}
\titlepage
\end{frame}


\begin{frame}[fragile]{TODO}
\begin{itemize}
\item Repeat stuff
\item Did I do input processing last time?
\item add cosimulation to the verification story (show Lipsi), maybe later
\item logic gen., maybe bin bcd directly into vec
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Overview}
\begin{itemize}
\item Repeat
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Factoring FSMs}
\begin{itemize}
\item yyy

Divide a big problem into several smaller problems
Splitting a FSM into two or more
Simplify the design
FSMs communicate via logic signals
FSM provides input controls signals to another
FSM senses output from another
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Specification Of a Light Flasher}
\begin{itemize}
\item yyy
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Light Flasher State Diagram}
\begin{itemize}
\item yyy
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Specification Change}
\begin{itemize}
\item yyy
We have a flat FSM with 27 states
27 when statements
If we change the specification to
12 cycles for each flash
4 flashes
7 cycles between flashes
Complete change of case statement
Now 70 when statements!
This does not scale

\end{itemize}
\end{frame}

\begin{frame}[fragile]{Factor Light Flasher}
\begin{itemize}
\item yyy
Factor out counting on and off intervals
Into a timer
Reduces 6 and 4 states sequences into two single states
Results in
a master FSM and
a timer FSM
Simplifies FSMs
Allows easier change of interval lengths
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Factored Light Flasher}
\begin{itemize}
\item yyy
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Timer Specification}
\begin{itemize}
\item TODO: is this the timer I presented last week?
\item
Two inputs
tload to load the down counter
tsel to select between 6 and 4 cycles counting
Output
done is 1 when counter has completed the countdown, remains asserted until counter reloaded
Counter can be (re)loaded in any state
When not loaded it counts down to zero
\end{itemize}
\end{frame}

\begin{frame}[fragile]{State Diagram of Factored Light Flasher}
\begin{itemize}
\item yyy
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Waveforms from simulation of light-flasher FSM}
\begin{itemize}
\item yyy
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Result of Refactoring}
\begin{itemize}
\item yyy
State of original flat FSM has been separated
The part of cycle counting in the counter
Part flash or space in master FSM
Represent original 27 states in just two 6 states FSMs

BTW: the master FSM is a Mealy FSM
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Still Redundancy in FSM}
\begin{itemize}
\item yyy
A, C, and E are the same
B and D are the same
A -- B is the same as C -- D
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Factor out ``flash number''}
\begin{itemize}
\item yyy
\end{itemize}
\end{frame}

\begin{frame}[fragile]{State diagram of twice-factored light flasher}
\begin{itemize}
\item yyy
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Benefits of Refactored Solution}
\begin{itemize}
\item yyy
Master FSM has just three states: OFF, FLASH, and SPACE
Change of intervals or number of flashes needs no change in the FSM
Smaller components are easier to read and simpler to test individually

\end{itemize}
\end{frame}

\begin{frame}[fragile]{Usage in your VM}
\begin{itemize}
\item yyy
Maybe factor out the edge detection for the button(s)
Use a timer for more advanced user interface
Blinking LED on some error
Write text as a banner in the 7-segment display
...
\end{itemize}
\end{frame}

\begin{frame}[fragile]{xxx}
\begin{itemize}
\item yyy
\end{itemize}
\end{frame}

\begin{frame}[fragile]{xxx}
\begin{itemize}
\item yyy
\end{itemize}
\end{frame}

\begin{frame}[fragile]{xxx}
\begin{itemize}
\item yyy
\end{itemize}
\end{frame}

\begin{frame}[fragile]{xxx}
\begin{itemize}
\item yyy
\end{itemize}
\end{frame}

\begin{frame}[fragile]{xxx}
\begin{itemize}
\item yyy
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Functions}
\begin{itemize}
\item Circuits can be encapsulated in functions
\item Each \emph{function call} generates hardware
\item Simple functions can be a single line
\end{itemize}
\begin{chisel}
  def adder(v1: UInt, v2: UInt) = v1 + v2
  
  val add1 = adder(a, b)
  val add2 = adder(c, d)
\end{chisel}
\end{frame}

\begin{frame}[fragile]{More Function Examples}
\begin{itemize}
\item Functions can also contain registers
\end{itemize}
\begin{chisel}
  def addSub(add: Bool, a: UInt, b: UInt) =
    Mux(add, a + b, a - b)

  val res = addSub(cond, a, b)

  def rising(d: Bool) = d && !RegNext(d)

  val edge = rising(cond)
\end{chisel}
\end{frame}

\begin{frame}[fragile]{The Counter as a Function}
\begin{itemize}
\item Longer functions in curly brackets
\item Last value is the return value
\end{itemize}
\begin{chisel}
def counter(n: UInt) = {
  
  val cntReg = RegInit(0.U(8.W))
  
  cntReg := cntReg + 1.U
  when(cntReg === n) {
    cntReg := 0.U
  }
  cntReg
}

val counter100 = counter(100.U)
\end{chisel}
\end{frame}

\begin{frame}[fragile]{Functional Abstraction}
\begin{chisel}
  def addSub(add: Bool, a: UInt, b: UInt) =
    Mux(add, a+b, a-b)

  val res = addSub(cond, a, b)
  
  def rising(d: Bool) = d && !RegNext(d)
\end{chisel}
\begin{itemize}
\item Functions for repeated pieces of logic
\item May contain state
\item Functions may return \emph{hardware}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Functions}
\begin{itemize}
\item Example from Patmos execute stage
\end{itemize}
\begin{chisel}
def alu(func: Bits, op1: UInt, op2: UInt): Bits = {
  val result = UInt(width = DATA_WIDTH)
  // some more lines...
  switch(func) {
    is(FUNC_ADD) { result := sum }
    is(FUNC_SUB) { result := op1 - op2 }
    is(FUNC_XOR) { result := (op1 ^ op2).toUInt }
    // some more lines
  }
  result
}
\end{chisel}
\end{frame}

\begin{frame}[fragile]{Today Lab}
\begin{itemize}
\item xxx
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Summary}
\begin{itemize}
\item yyy
Divide a bigger problem into smaller ones
Easier to design
Easier to test
Sometimes only feasible solution
Factoring state machines
Separate state into multiple `orthogonal' state variables
Each is simpler to handle (fewer states)
``Factors out'' repetitive sequences
Hierarchical structure
\end{itemize}
\end{frame}



\end{document}

%\begin{frame}[fragile]{xxx}
%\begin{itemize}
%\item yyy
%\end{itemize}
%\end{frame}
