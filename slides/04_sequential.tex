\input{slides_common}

\newif\ifbook
\input{../shared/chisel}


\title{Components and Sequential Circuits}
\author{Martin Schoeberl}
\date{\today}
\institute{Technical University of Denmark\\
Embedded Systems Engineering}

\begin{document}

\begin{frame}
\titlepage
\end{frame}


\begin{frame}[fragile]{Overview}
\begin{itemize}
\item Now just  collection of future slides
\item TODO: did I collect all the short intro slides here?
\item Start with bundle, IO, Moduls, main, App
\item Chisel: 3.1, 3.2, 4 and 6 (6.2., 6.3)
\item TODOs
\item minimize use of acronyms, also check other slides
\item Have a acronym section in the book - DO IT NOW
\item have asX here and in the book
\item go through the book
\item Have a ref to the Java lecture
\item The main program (compare Java with Scala)
\item Introduce vending machine
\item Show git commands, in slides and do live the clone, update, and pull. Point to gui version. Show that you can even do the git pull in IntelliJ
\end{itemize}
\end{frame}


\begin{frame}[fragile]{Power User II}
\begin{itemize}
\item xxx
 * Talk about tools
   * see chapter 3 in pragmatic programmer
   * Tools amplify your talent. The better your tools, and the better you know how to use them, the more productive you can be.
   * Talk about google, man pages, or even plain --help
 * Use (and write) tools
 * link is missing: use simple bash scripts or Makefiles to remember commands (show examples)


 * Do power user in week 4
 * Have some slides, but mostly show demo
 * link to Linux intro
 * Use the Windows VM
 * open a powershell terminal
 * do a mkdir
 * do ls and cd
 * open browser to repo and copy string
 * do a git clone
 * cd and ls, maybe a cat
 * setup IntelliJ
 * run one exercise
 * switch to Mac and change minor thing
 * Do git commit/push
 * do a git pull in Windows, show in IntelliJ README.md
 * On Mac go to GitHub page
 * Do a change
 * On Windows do a git pull in IntelliJ
 * Say to take it easy, you do not need to do this, but it will help you to become a better engineer ;-)
\item \url{https://www.oreilly.com/learning/ten-steps-to-linux-survival}

\end{itemize}
\end{frame}

\begin{frame}[fragile]{Power User II}
\begin{itemize}
\item Every craftsmen starts with good-quality tools
\item ``Tools amplify your talent''\footnote{The Pragmatic Programmer: From Journeyman to Master, by Andrew Hunt and David Thomas}
\begin{itemize}
\item The better your tools, the more productive you are
\item The better you know them, the more productive you are
\end{itemize}
\item IDEs (Eclipse, InelliJ) are nice, I love them too
\item But we shall go beyond it
\item
\item
\item
\end{itemize}
\end{frame}

\begin{frame}[fragile]{XXX}
\begin{itemize}
\item
\item
\item
\end{itemize}
\end{frame}

\begin{frame}[fragile]{XXX}
\begin{itemize}
\item
\item
\item
\end{itemize}
\end{frame}


\begin{frame}[fragile]{XXX}
\begin{itemize}
\item xxx
\begin{itemize}
\item
\end{itemize}
\item
\item
\item
\item
\item
\end{itemize}
\end{frame}


\begin{frame}[fragile]{Verilog Generation}
\begin{itemize}
\item TODO: show individual snippets
\item on @[Hello.scala 17:23]
\begin{itemize}
\item
\end{itemize}
\item about pin names, e.g., \code{io\_led}
\item
\item
\item
\item
\end{itemize}
\begin{verbatim}
module Hello(
  input   clock,
  input   reset,
  output  io_led
);
  reg [31:0] cntReg; // @[Hello.scala 17:23]
  reg [31:0] _RAND_0;
  reg  blkReg; // @[Hello.scala 18:23]
  reg [31:0] _RAND_1;
  wire [31:0] _T_1; // @[Hello.scala 20:20]
  wire  _T_2; // @[Hello.scala 21:15]
  wire  _T_3; // @[Hello.scala 23:15]
  assign _T_1 = cntReg + 32'h1; // @[Hello.scala 20:20]
  assign _T_2 = cntReg == 32'h2faf07f; // @[Hello.scala 21:15]
  assign _T_3 = ~ blkReg; // @[Hello.scala 23:15]
  assign io_led = blkReg; // @[Hello.scala 25:10]
`ifdef RANDOMIZE_GARBAGE_ASSIGN
`define RANDOMIZE
`endif
`ifdef RANDOMIZE_INVALID_ASSIGN
`define RANDOMIZE
`endif
`ifdef RANDOMIZE_REG_INIT
`define RANDOMIZE
`endif
`ifdef RANDOMIZE_MEM_INIT
`define RANDOMIZE
`endif
`ifndef RANDOM
`define RANDOM $random
`endif
`ifdef RANDOMIZE_MEM_INIT
  integer initvar;
`endif
`ifndef SYNTHESIS
initial begin
  `ifdef RANDOMIZE
    `ifdef INIT_RANDOM
      `INIT_RANDOM
    `endif
    `ifndef VERILATOR
      `ifdef RANDOMIZE_DELAY
        #`RANDOMIZE_DELAY begin end
      `else
        #0.002 begin end
      `endif
    `endif
  `ifdef RANDOMIZE_REG_INIT
  _RAND_0 = {1{`RANDOM}};
  cntReg = _RAND_0[31:0];
  `endif // RANDOMIZE_REG_INIT
  `ifdef RANDOMIZE_REG_INIT
  _RAND_1 = {1{`RANDOM}};
  blkReg = _RAND_1[0:0];
  `endif // RANDOMIZE_REG_INIT
  `endif // RANDOMIZE
end // initial
`endif // SYNTHESIS
  always @(posedge clock) begin
    if (reset) begin
      cntReg <= 32'h0;
    end else if (_T_2) begin
      cntReg <= 32'h0;
    end else begin
      cntReg <= _T_1;
    end
    if (reset) begin
      blkReg <= 1'h0;
    end else if (_T_2) begin
      blkReg <= _T_3;
    end
  end
endmodule

\end{verbatim}
\end{frame}

\begin{frame}[fragile]{File Organization in Scala/Chisel}
\begin{itemize}
\item A Scala file can contain several classes (and objects)
\item For large classes use one file per class with the class name
\item Scala has packages, like Java
\item Use folders with the package names for file organization
\item \code{sbt} looks into current folder and \code{src/main/scala/}
\item Tests shall be in \code{src/test/scala/}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{File Organization in Scala/Chisel}
\dirtree{%
.1 project.
.2 src.
.3 main.
.4 scala.
.5 package.
.6 sub-package.
.3 test.
.4 scala.
.5 package.
.2 target.
.2 generated.
}
\end{frame}

\begin{frame}[fragile]{XXX}
\begin{itemize}
\item xxx
\begin{itemize}
\item
\end{itemize}
\item
\item
\item
\item
\item
\end{itemize}
\end{frame}


\begin{frame}[fragile]{XXX}
\begin{itemize}
\item xxx
\begin{itemize}
\item
\end{itemize}
\item
\item
\item
\item
\item
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Common Acronyms}
\begin{description}
\item [ADC] analog-to-digital converter
\item [ALU] arithmetic and logic unit
\item [ASIC] application-specific integrated circuit
\item [Chisel] constructing hardware in a Scala embedded language
\item [CISC] complex instruction set computer
\item [CRC] cyclic redundancy check
\item [DFF] D flip-flop, data flip-flop
\item [DMA] direct memory access
\item [DRAM] dynamic random access memory
\item [FF] flip-flop
\item [FIFO] first-in, first-out
\item [FPGA] field-programmable gate array
\item [HDL] hardware description language
\item [HLS] high-level synthesis
\item [IC] instruction count
\item [IDE] integrated development environment
\item [IO] input/output
\end{description}
\end{frame}

\begin{frame}[fragile]{Common Acronyms II}
\begin{description}
\item [ISA] instruction set architecture
\item [JDK] Java development kit
\item [JIT] just-Iin-time
\item [JVM] Java virtual machine
\item [LC] logic cell
\item [LRU] least-recently used
\item [MMIO] memory-mapped IO
\item [MUX] multiplexer
\item [OO] object oriented
\item [RISC] reduced instruction set computer
\item [SDRAM] synchronous DRAM
\item [SRAM] static random access memory
\item [TOS] top-of stack
\item [UART] universal asynchronous receiver/transmitter
\item [VHDL] VHSIC hardware description language
\item [VHSIC] very high speed integrated circuit
\end{description}
\end{frame}

\begin{frame}[fragile]{Chisel VHDL Comparison}
\begin{columns}
\column{0.5\textwidth}
\begin{chisel}
class DecodeExecute extends Bundle {
  val rs1 = UInt(32.W)
  val rs2 = UInt(32.W)
  val immVal = UInt(32.W)
  val aluOp = new AluOp()
}
\end{chisel}
\column{0.5\textwidth}
\begin{verbatim}
VHDL code here
\end{verbatim}
\end{columns}
Also show latch and and using a button as clock
\end{frame}


\begin{frame}[fragile]{Functional Abstraction}
\begin{chisel}
  def addSub(add: Bool, a: UInt, b: UInt) =
    Mux(add, a+b, a-b)

  val res = addSub(cond, a, b)
  
  def rising(d: Bool) = d && !RegNext(d)
\end{chisel}
\begin{itemize}
\item Functions for repeated pieces of logic
\item May contain state
\item Functions may return \emph{hardware}
\end{itemize}
\end{frame}


\begin{frame}[fragile]{Bundles}
\begin{chisel}
class DecodeExecute extends Bundle {
  val rs1 = UInt(32.W)
  val rs2 = UInt(32.W)
  val immVal = UInt(32.W)
  val aluOp = new AluOp()
}
\end{chisel}
\begin{itemize}
\item Collection of values in named fields 
\item Like struct or record
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Vectors}
\begin{chisel}
val myVec = Vec(3, SInt(10.W))

myVec(0) := -3.S
val y = myVec(2)
\end{chisel}
\begin{itemize}
\item Indexable vector of elements
\item Bundles and Vecs can be arbitrarely nested
\end{itemize}
\end{frame}

\begin{frame}[fragile]{IO Ports}
\begin{chisel}
class Channel extends Bundle {
  val data = Input(UInt(8.W))
  val ready = Output(Bool())
  val valid = Input(Bool())
}
\end{chisel}
\begin{itemize}
\item Ports are Bundles with directions
\item Direction can also be assigned at instantiation:
\end{itemize}
\begin{chisel}
class ExecuteIO extends Bundle {
  val dec = Input(new DecodeExecute())
  val mem = Output(new ExecuteMemory())
}
\end{chisel}
\end{frame}

\begin{frame}[fragile]{Modules}
\begin{chisel}
class Adder extends Module {
  val io = IO(new Bundle {
    val a = Input(UInt(4.W))
    val b = Input(UInt(4.W))
    val result = Output(UInt(4.W))
  })

  val addVal = io.a + io.b
  io.result := addVal
}
\end{chisel}
\begin{itemize}
\item Organization of components
\item IO ports defined as a Bundle named \code{io} and wrapped into an \code{IO()}
\item Created (instantiated) with:
\end{itemize}
\begin{chisel}
val adder = Module(new Adder())
\end{chisel}
\end{frame}

\begin{frame}[fragile]{Connections}
\begin{itemize}
\item Simple connections just with assignments, e.g.,
\begin{chisel}
  adder.io.a := ina
  adder.io.b := inb
\end{chisel}
\item Automatic bulk connections between components
\begin{chisel}
  dec.io <> exe.io
  mem.io <> exe.io
\end{chisel}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Generic Components}
\begin{chisel}
val c = Mux(cond, a, b)
\end{chisel}
\begin{itemize}
\item This is a multiplexer
\item Input can be any type
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Testing}
\begin{chisel}
class CounterTester(c: Counter) extends PeekPokeTester(c) {
  for (i <- 0 until 5) {
    println(i.toString + ": " + peek(c.io.out).toString())
    step(1)
  }
}
\end{chisel}
\begin{itemize}
\item Within Chisel with a tester (= Scala program)
\item May include waveform generation
\item peek and poke to read and set values
\begin{itemize}
\item Remember the BASIC days ;-)
\end{itemize}
\item printf in simulation on rising edge
\begin{chisel}
printf("Counting %x\n", r1)
\end{chisel}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Component Generation}
\begin{chisel}
val cores = new Array[Module](32)

for (j <- 0 until 32)
  cores(j) = Module(new CPU())
\end{chisel}
\begin{itemize}
\item Use Scala array to collect components
\item Generation with a Scala loop
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Conditional Component Generation}
\begin{chisel}
val icache =
  if (TYPE == METHOD)
    Module(new MCache())
  else if (TYPE == LINE)
    Module(new ICache())
  else
    ChiselError.error("Unsupported Type")
\end{chisel}
\begin{itemize}
\item Use Scala if/else for conditional component types
\item Code example from Patmos
\item We parse an XML file for the configuration
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Logic Generation}
\begin{itemize}
\item Read a file into a table
\begin{itemize}
\item E.g., to read in ROM content for a processor
\end{itemize}
\item Generate a truth table algorithmically
\begin{itemize}
\item E.g., generate binary to BCD translation
\end{itemize}
\item Use the full power of Scala
\end{itemize}
\begin{chisel}
val byteArray = Files.readAllBytes(Paths.get(fileName))
val arr = new Array[Bits](byteArray.length)
for (i <- 0 until byteArray.length) {
  arr(i) = Bits(byteArray(i), 8)
}
val rom = Vec[Bits](arr)
\end{chisel}
\end{frame}
%%%%%%%%%%%%%%%%%
%\begin{frame}[fragile]{zzz}
%\begin{chisel}
%code
%\end{chisel}
%\begin{itemize}
%\item xxx
%\item xxx
%\item xxx
%\end{itemize}
%\end{frame}
%
%\begin{frame}[fragile]{yyy}
%\begin{itemize}
%\item xxx
%\item xxx
%\item xxx
%\item xxx
%\item xxx
%\end{itemize}
%\end{frame}
%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{What is a Minimal Chisel Project?}
\begin{itemize}
\item Scala class (e.g., \code{Hello.scala})
\item Build info in \code{build.sbt} for \code{sbt}:
\end{itemize}
\begin{chisel}
scalaVersion := "2.11.7"

libraryDependencies += "edu.berkeley.cs" %% "chisel3" % "3.1.2"
\end{chisel}
\begin{itemize}
\item Run the process manually (look into the Makefile)
\end{itemize}
\end{frame}

\end{document}

\begin{frame}[fragile]{Summary}
\begin{itemize}
\item abc
\end{itemize}
\end{frame}
